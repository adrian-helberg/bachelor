% @author Arian Helberg

\chapter{Konzepte}
Mit der Erstellung eines Programms zur Synthetisierung von Ähnlichkeitsabbildungen einer vom Benutzer
erstellten Verzweigungsstruktur soll die Praktibilität aktueller Forschungsansätze untersucht werden.
\\~\\
Folgende Kernkonzepte werden erläutert und umgesetzt:
\begin{itemize}
    \item Visualisierung und prozessorientiertes Erstellen von Basisstrukturen,
    \item Organisation in einer prozessoptimierten, baumähnlichen Topologie,
    \item L-System-Repräsentationen,
    \item Algorithmen zur Inferierung, Komprimierung, Generalisierung und
    \item Verarbeitung von Transformationsparametern
\end{itemize}

\section{Probleme \& Lösungsansätze}

\subsection*{Visualisierung}
Um eine geführte Erstellung der Basisstruktur zu ermöglichen, muss diese während der Erstellung sichtbar gemacht werden.
Hierzu werden die Templates in Form von Zeichenketten angelegt und mittels Turtle-Grafik visualisiert.
Eine Turtle-Grafik beschreibt die Interpretation einer Zeichenkette als Bild durch Ausführen eines Logo-Turtle-Algorithmus.
Weiter wird auch zur Evaluation von Ergebnissen eine Visualisierung benötigt.
Da die Verzweigungsstrukturen in L-System-Repräsentation vorliegen, wird hierzu eine Interpretationsfunktion benötigt,
die diese Ersetzungssysteme in Bildform darstellen.
Ein L-System wird durch Ausführung in eine erweiterte Zeichenkette überführt und als Turtle-Grafik beschrieben
~\cite{prusinkiewicz_1986}.

\subsection*{Basisstruktur}
Der Benutzer nutzt grafische Bendienelemente, um eingelesene Templates auszuwählen, Transformationsparameter anzupassen
und um anschließend die Instanzen der Basisstruktur hinzuzufügen.
Im Folgenden wird diese Basisstruktur u.a. Grundstruktur und Eingabestruktur genannt.

\subsection*{Baumstruktur}
Um Grundstrukturen mittels verschiedener Algorithmen untersuchen zu können, werden die einzelnen Template-Instanzen in
einer baumähnlichen Struktur organisiert.
Transformationsparameter einer Instanz beschreiben die räumlichen Veränderung gegenüber des zugrundeliegenden Templates
und haben daher keine Aussagekraft in Bezug auf die Strukturtopologie der Basisstruktur.
Diese Arbeit fokussiert sich auf topologische Eigenschaften von Verzweigungsstrukturen (z.B. Rekursionen).
Darum bilden die einzelnen Template-Instanzen die Knoten der Baumtopologie, während die Kanten die räumlichen Transformationen
darstellen.
So wird eine datenstrukturelle Trennung zwischen Topologie und räumlichen Transformationen geschaffen.
Diese baumähnliche Struktur ist ispiriert durch~\cite{guo_2020}, Kapitel 4.2 \textit{Grammar inference}

\subsection*{Inferieren}
Das Smallest Grammar Problem, also das Finden der kleinsten, kontextfreien Grammatik, welche eine bestimmte Zeichenkette
generiert, ist ein offenes Problem der Informatik mit einem Annäherungsverhältnis von weniger als $\frac{8569}{8568}$
(NP-hard).
Primär wird in der Forschung nach Algorithmen gesucht, die ein akzeptables Ergebnis liefern.
In dieser Arbeit wird ein Algorithmus präsentiert, der die Knoten der Baumstruktur in einzelne Symbole umwandelt, mit
Produktionregeln verknüpft und diese dem resultierenden L-System hinzufügt.
Dieses L-System repräsentiert lediglich die Eingabestruktur.

\subsection*{Komprimieren}
Um ein kompaktes, gewichtetes L-System zu erzeugen, werden sich wiederholende Unterrbäume gesucht und ersetzt.
Eine Gewichtung wird angewendet, um das zu erzeugende L-System mit kleiner Regelmenge oder mit
großer Regelmenge auszustatten.
Eine Kostenfunktion stellt hierbei die Anzahl Symbole aller RHS der Produktionsregeln mit der Menge an Anwendungen der
LHS gegenüber.

\subsection*{Generalisieren}
Da das kompakte L-System eine Repräsentation der vom Benutzer erzeugten Verzweigungsstruktur darstellt, werden ähnliche
Regeln miteinander verbunden (Merge) und mit einer Wahrscheinlichkeit versehen, um nicht-deterministische Regeln hinzuzufügen.
Eine weitere Kostenfunktion bewertet den Merge zweier Produktionregeln und wendet eine Gewichtung über die Länge der Grammatik
zur Änderungsdistanz der alten (ohne Merge) zur neuen Grammatik um.

\subsection*{Transformationen}
Die vom Benutzer vergeben Werte der Transformationsparameter werden während der Erstellung der Eingabestruktur in
einer Häufigkietsverteilung organisiert und bei Ausführung des generalisierten L-Systems angewendet.
So werden Transformationen nach ihrer statistischen Häufigkeit angewendet.

\section{Softwarearchitektur}

Die Gliederung der Inhalte für die Softwarearchitektur erfolgt nach der arc42-Vorlage~\cite{arc42}

\subsection*{Qualitätsziele}
Um die wesentlichen Features des Systems in einem Programm umzusetzen, werden folgende Qualitätsziele definiert,
priorisiert (absteigend) und umgesetzt:
\begin{itemize}
    \item \textbf{Funktionalität} durch Umsetzen aller Teilsysteme in Vollständigkeit, Korrektheit, Angemessenheit
    \item \textbf{Interoperabilität} durch Nutzen einer allgemeinen Repräsentation von L-Systemen, damit diese
    auch in anderen Programmen oder Algorithmen verwendet werden kann
    \item \textbf{Erweiterbarkeit} durch offene Entwurfsmuster (Design Patterns)
    \item \textbf{Modularität} durch Implementierung für effiziente Wartung und Erweiterung
    \item \textbf{Effizienz} durch effiziente Programmierung
    \item \textbf{Attraktivität} durch intuitive Benutzung (Benutzerfreundlichkeit)
    \item \textbf{Plattformunabhängigkeit} durch Verwenden des Java-Frameworks
\end{itemize}

\subsection*{Kontextabgrenzung}
Die Systemgrenzen werden zum Einen durch die Interaktion mit dem Benutzer, zum Anderen durch die Interaktion mit
dem Dateisystem des Host-Systems und dem Zugreifen und Lesen der Template-Dateien definiert.
Hierbei wird die Erstellung der Basisstruktur als nicht-technische Interaktion und das Einlesen der Dateien als
technische Interaktion gesehen.
\begin{figure}[H]
    \centering
    \includegraphics[width=6.2cm]{../images/Fachlicher_Kontext.PNG}
    \caption{System und Systemumgebung}
\end{figure}
\begin{figure}[H]
    \centering
    \includegraphics[width=10cm]{../images/Technischer_Kontext.PNG}
    \caption{Interaktion zwischen System und Systemumgebung}
\end{figure}

\newpage

\subsection*{Lösungsstrategie}
Zur Erreichung der o.g. Qualitätsziele werden folgende Architekuransätze umgesetzt:
\begin{center}
    \begin{tabular}{l|l}
        \textbf{Qualitätsziel} & \textbf{Architekturansatz} \\
        \hline \\
        Funktionalität &
        \begin{minipage}[t]{0.8\textwidth}
            Grafische Benutzerschnittstelle\\
            Generieren der Baumstruktur\\
            Verarbeiten von L-Systemen
        \end{minipage} \\
        \\ \hline \\
        Interoperabilität &
        \begin{minipage}[t]{0.8\textwidth}
            Durch das Nutzen allgemeingültiger mathematischer Beschreibungen sollen erstellte
            L-Systeme in Fremdsystemen, wie Online Visualisierer, genutzt werden können
        \end{minipage} \\
        \\ \hline \\
        Erweiterbarkeit &
        \begin{minipage}[t]{0.8\textwidth}
            Das Nutzen des Pipeline Design Patterns soll das Erweitern des Systems durch
            Hinzufügen weiterer Teilschritte (Pipes) erleichtern.
            Trennung der grafischen Oberfläche und der Logik durch Aufbauen des Szenengraphen über ein
            XML-Dateiformat
        \end{minipage} \\
        \\ \hline \\
        Modularität &
        \begin{minipage}[t]{0.8\textwidth}
            Sowohl eine sinnvolle Aufteilung von Funktionalitäten auf Dateien und Software-Pakete, als
            auch effiziente Datenkapselung und geschlossene Informationskontexte sorgen für Modularität des
            Programms
        \end{minipage} \\
        \\ \hline
    \end{tabular}
\end{center}

\subsection*{Bausteinsicht}
\underline{Ebene 1}
\begin{figure}[H]
    \centering
    \includegraphics[width=12cm]{../images/Bausteinsicht_Ebene_1.PNG}
    \caption{Subsysteme mit fachlichen Abhängigkeiten}
\end{figure}
\underline{Ebene 2}
\begin{figure}[H]
    \centering
    \includegraphics[width=9cm]{../images/Bausteinsicht_Ebene_2.PNG}
    \caption{Subsystem GUI}
\end{figure}

\subsection{Laufzeitsicht}
\begin{figure}[H]
    \centering
    \includegraphics[width=14cm]{../images/Laufzeitsicht.PNG}
    \caption{Laufzeitsicht}
\end{figure}

\subsection{Verteilungsicht}
\begin{figure}[H]
    \centering
    \includegraphics[width=10cm]{../images/Verteilungssicht.PNG}
    \caption{Infrastruktur Windows-PC}
\end{figure}

\subsection{Konzepte}

\subsubsection{Testbarkeit}
Um eine ausreichende Testabdeckung zu erreichen, werden Klassen als kleinstmögliche zu testende Einheit definiert
und durch Komponententests geprüft.
Der Name eines Tests setzt sich aus dem Präfix als Name der zu testenden Klasse oder Releases und dem Suffix
"`Test"'
zusammen.
Testsubjekte werden als \textbf{Blackbox} behandelt, also anhand der Spezifikation getestet.
\begin{center}
    Bsp.: Klasse \textit{Inferer} mit Komponententest \textit{InfererTest}
\end{center}
Da jedes Release der Implementierung ein funktionsfähiges System beinhaltet, kann auf Integrationstests
verzichtet werden.
Weiter wird ein Release anhand von funktionalen und nicht-funktionalen Anforderungen getestet.
Anhand dieser Systemtests wird geprüft, ob Gesamtspezifikationen umgesetzt worden sind.
\begin{center}
    Bsp.: Release 2 mit Systemtest \textit{Release2Test}
\end{center}
Zum Schluss der Implementierung wird ein Akzeptanztest durchgeführt.

\subsubsection{Validierung}
Der Benutzer des Systems nutzt ein grafische Schnittstelle.
Somit kann sichergestellt werden, dass dieser keine ungültigen Eingaben tätigt.
Werden Template-Dateien unter einem bestimmten Dateipfad nicht gefunden, wird eine \textit{NotFound}-Exception
protokolliert und dem Benutzer eine Nachricht über ein Pop-up mitgeteilt.
Eine \textit{IllegalArgumentException} wird verzeichnet und ausgegeben, wenn eingelesene Template-Dateien
strukturelle Fehler aufweisen.

\subsubsection{Fehlerbehandlung}
Zur Fehlersuche und -behandlung biete sich eine Protokollierung über Vorgänge, Fehler und Ausnahmen an.
Bestimmte Fehler werden dem Benutzer weitergegeben und grafisch angezeigt.
Folgende Subsysteme werden in das Programm integriert:
\begin{itemize}
    \item Ausnahmebehandlung (Exception Handling) und
    \item Protokollierung (Logging)
\end{itemize}
Erwartete Exceptions werden jeweils mit eigenen Klassen abgebildet, die von einer entsprechenden Klasse aus der
Exception-Hierarchie abgeleitet sind.
Das Logging ist statisch und überall im System zugreifbar, um eine einheitliche Protokollierung zu gewährleisten.

\subsubsection{Datenstrukturen}
TODO: Klassendiagramm aus IntelliJ generieren

\subsubsection{Workflows \& Algorithmen}
Um als Benutzer des Systems eine Verzweigungsstruktur zu erstellen, wird folgender Arbeitsablauf umgesetzt:
\begin{algorithm}[caption={Erstellen einer Verzweigungsstruktur}, label={alg1}]
    Erster Anker ist vorselektiert
    Wiederhole, bis Struktur fertiggestellt ist:
    Selektiere ein Template aus der Liste
    Setzt Parameter
    Bestätige Auswahl und Parameter
    Zeichne ausgewähltes Template mit Parameternd
    Wähle nächsten Anker aus
\end{algorithm}
\\~\\~\\
Aus der Verzweigungsstruktur kann nun ein L-System erzeugt werden:
\\~\\
Für $\mathcal{L}=\langle M,\omega,R \rangle$:
\begin{algorithm}[caption={Inferieren eines L-Systems aus einer Baumstruktur}, label={alg2}]
    Initialisierung:
    $M=\{F,S\}$
    $\omega=S$
    $R \gets \{\alpha$: $S \rightarrow A\}$
    $\beta=$ nächster Knoten*
    $M \gets \gamma \in \{A,B,\dots,Z\}$, mit $\gamma \notin M$

    Schleife:
    $\delta=$ Wort von $\beta$
    $\forall \{X,Y,Z\} \in \delta:$
    Ersetze mit $\zeta \in \{A,B,\dots,Z\}$, mit $\zeta \notin M$
    $M \gets \zeta$
    $R \gets \{\gamma\rightarrow\delta\}$
    Wenn es ein Symbol $\eta$ in $M\setminus\{F,S\}$ gibt mit $\{\eta \rightarrow bel.\} \notin R$:
    $\gamma=\eta$
    Sonst:
    Breche Schleife ab
    $\beta=$ nächster Knoten*
\end{algorithm}
\blfootnote{* nach Breitensuche, beginnend bei Wurzelknoten S}

\newpage


\begin{algorithm}[caption={Erstellen eines kompakten L-Systems mit Gewichtung $w_l$}, label={alg3}]
Initialisierung:
$\mathcal{L}^+ \leftarrow L_s$*
$\mathcal{L}=\emptyset$
Setze Gewichtungsparameter $w_l \in [0,1]$
Finde maximalen Unterbaum $T'$ aus $T$** mit Wiederholungen $n$

Reduzierung:
if n > 1
Ersetze alle Vorkommen von $T'$ mit dem selben Symbol $\gamma \in \{A,B,\dots,Z\}$
$R \leftarrow \{\gamma \rightarrow L_s\}$ mit $L_s$ aus $T'$, $R$ aus $\mathcal{L}$
if $C_i(\mathcal{L}) \geq C_i(\mathcal{L}^+)$
break
$T \leftarrow T'$
$\mathcal{L}^+ \leftarrow \mathcal{L}$
Finde maximalen Unterbaum $T'$ aus $T$ mit Wiederholungen $n$
\end{algorithm}
\blfootnote{* $L_s$ als Zeichenkette des Ausgeführten L-Systems $\mathcal{L}=\langle M,\omega,R \rangle$}
\blfootnote{** $T$ als Baumstruktur des L-Systems}

\begin{algorithm}[caption={Kostenfunktion $C_i$ mit Gewichtung $w_l$}, label={alg4}]
$C_i(\mathcal{L})= \sum\limits_{A(P) \rightarrow M^* \in \mathcal{L}} w_l * |M^*| + (1 - w_l) * N(A(P)\rightarrow
M^*)$***
\end{algorithm}
\blfootnote{*** $N(\cdot)$ als Zählfunktion für die Anzahl Wiederholungen einer \textit{LHS} einer Regel in einem
ausgeführten L-System}

Da das kompakte L-System eine Repräsentation der vom Benutzer erzeugten Verzweigungsstruktur darstellt, werden
nun ähnliche Regeln miteinander verbunden und mit einer Wahrscheinlichkeit versehen, um nicht-deterministische
Regeln hinzuzufügen.

\begin{algorithm}[caption={Längenfunktion $L$ für Grammatiken}, label={alg5}]
$L(\mathcal{L}) = |M| + \sum\limits_{A(P) \rightarrow M^* \in \mathcal{L}} |M^*|$
\end{algorithm}

\begin{algorithm}[caption={Kostenfunktion $C_g$ mit Gewichtung $w_0$}, label={alg6}]
$C_g(\mathcal{L}^*, \mathcal{L}^+) = w_0 * (L(\mathcal{L}^*) - L(\mathcal{L}^+)) + (1 - w_0) + D_g
(\mathcal{L}^+, \mathcal{L}^*)$
\end{algorithm}

\begin{algorithm}[caption={Generalisieren eines L-Systems mit Gewichtung $w_0$}, label={alg7}]
Initialisierung:
Regelpaar $p* = \emptyset$
$\mathcal{L}^* = \mathcal{L}^+$
$C_g^{old} = C_g(\mathcal{L}^* + \{p^*\}, \mathcal{L}^*)$

Schleife:
do
Finde Regelpaar $p^*$ mit minimalen Kosten $C_g(\mathcal{L}^* + \{p_i\}, \mathcal{L}^*), \forall p_i \in
\mathcal{P}$*
if $C_g(\mathcal{L}^* + \{p^*\}, \mathcal{L}^*) \geq 0$
break
$c^* = C_g(\mathcal{L}^* + \{p^*\}, \mathcal{L}^*) - C_g^{old}$
$C_g^{old} = C_g(\mathcal{L}^* + \{p^*\}, \mathcal{L}^*)$
$\mathcal{L}^* = \mathcal{L}^* + \{p^*\}$
while $c^* \leq 0$
\end{algorithm}
\blfootnote{* $\mathcal{P}$ als Menge aller möglichen Regelpaaren aus $\mathcal{L}^*$}